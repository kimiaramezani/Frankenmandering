# -*- coding: utf-8 -*-
"""MCMC_Baseline_6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jLYUhxbzpx3wZnKXgYZxyO8Al_3yHQc0
"""

!pip install torch_geometric

"""Initial baseline update & reward

*   Read current labels from env_work.FrankenData.dist_label.
*   Convert labels to an action matrix with labels_to_action.

Call env_work.step(action_curr). This runs env.step


The returned reward_curr becomes the baseline reward for Metropolis comparisons. This also ensures env_work reflects the post-step opinions (so proposals are compared against a consistent oldX).
"""

import numpy as np
import torch
from torch_geometric.data import Data
import gymnasium as gym
from gymnasium import spaces
import gerry_environment
from copy import deepcopy
from typing import Optional, Tuple, Dict, Any
import math

def labels_to_action(labels, num_districts, dtype=np.float32):
    """
    Convert an integer label vector (shape [N]) to an action matrix
    expected by env.step: shape (N, num_districts), each row is
    a 1-hot encoding of the desired district for that voter.
    """
    N = len(labels)
    A = np.zeros((N, num_districts), dtype=dtype)
    for i, lab in enumerate(labels):
        if lab >= 0 and lab < num_districts:
            A[i, int(lab)] = 1.0
        else:
            # keep row zeros -> will become -1 label in env.step (avoid if possible)
            pass
    return A



"""#**propose_flip**

The function implements a two-district cluster flip closely following the paper’s steps:

Choose a boundary/adjacent district pair (pick a cut edge).

Construct monochromatic internal edges for those two districts and optionally keep each internal edge with probability p_keep (this implements the Swendsen–Wang style random edge labeling).

Find the connected component (cluster) containing the chosen seed node u.

Flip that whole cluster to the other neighboring district.

Validate the proposed labels (no empty districts, contiguity) and reject if invalid
"""



import numpy as np

def propose_flip(labels, geo_edge, rng, p_keep=0.5):
    """
    Propose a flip following the BFS-from-cut-edge style:
      1. pick random cut edge (u,v)
      2. grow a cluster in one district using BFS with kept mono edges
      3. flip cluster to the other district
      4. reject if it empties a district or breaks contiguity
    """
    N = len(labels)
    labels = labels.astype(int)

    # Step 1: collect cut edges (u,v where districts differ)
    diff_edges = [(int(u), int(v)) for u, v in geo_edge.T if labels[u] != labels[v]]
    if not diff_edges:
        return labels.copy()

    # pick random cut edge
    u, v = diff_edges[rng.integers(len(diff_edges))]
    dA, dB = labels[u], labels[v]

    # Step 2: build adjacency restricted to {dA,dB}, keep edges with prob p_keep
    adj = [[] for _ in range(N)]
    for x, y in geo_edge.T:
        if labels[x] == labels[y] and labels[x] in (dA, dB):
            if rng.random() < p_keep:
                adj[x].append(y)
                adj[y].append(x)

    # BFS cluster starting from u
    cluster = set()
    stack = [u]
    while stack:
        node = stack.pop()
        if node in cluster:
            continue
        cluster.add(node)
        stack.extend(adj[node])

    # Step 3: flip cluster to other district
    cluster_label = labels[u]
    target = dB if cluster_label == dA else dA
    new_labels = labels.copy()
    for node in cluster:
        new_labels[node] = target

    # Step 4a: non-empty check
    if not np.any(new_labels == dA) or not np.any(new_labels == dB):
        return labels.copy()

    # Step 4b: contiguity check
    def is_contiguous(lab):
        nodes = [i for i in range(N) if new_labels[i] == lab]
        if not nodes:
            return False
        seen = {nodes[0]}
        stack = [nodes[0]]
        while stack:
            n = stack.pop()
            for x, y in geo_edge.T:
                if x == n and new_labels[y] == lab and y not in seen:
                    seen.add(y); stack.append(y)
                elif y == n and new_labels[x] == lab and x not in seen:
                    seen.add(x); stack.append(x)
        return len(seen) == len(nodes)

    # only check districts that changed (source & target)
    if not is_contiguous(dA) or not is_contiguous(dB):
        return labels.copy()

    return new_labels



"""# **Main SA loop (hot → anneal → cold)**
For every SA iteration:

**1- Proposal generation (propose_flip):**
Chooses a border edge, builds a two-district cluster, flips it.
This is the proposal step.

**2- Pre-checks:**

Non-empty district check: all(np.any(y_prop == d) for d in ...). If a district would become empty, reject immediately.

Contiguity check: check_contiguity(geo_edge, y_prop, num_districts). If non-contiguous, reject immediately. This prevents expensive simulation for obviously invalid proposals.

**3- Evaluation (simulation):**

Convert y_prop into an action matrix with labels_to_action.

Make tmp_env = deepcopy(env_work) and call tmp_env.step(action_prop). That runs step and reward logic to produce reward_prop and tmp_env.FrankenData (the hypothetical post-proposal state).

This tmp_env.step is where the proposal is actually evaluated (it runs opinion update, elects reps, computes augmented graph and reward).

**4- Acceptance (Metropolis-style):**

Compute diff = reward_prop - reward_curr.
Acceptance probability p_accept = min(1, exp(diff / T)), where T is the current temperature (annealed linearly from T_init → T_final).

With probability p_accept accept the proposal: commit by setting env_work = tmp_env and reward_curr = reward_prop.

If rejected, env_work remains unchanged.
"""

def simulated_annealing(
    env,
    hot_steps,
    anneal_steps,
    cold_steps,
    T_init,
    T_final,
    seed,
    eps_indiff , eps_assim ,eps_backfire , eps_irrel , eps_amb ,
    assim_shift , back_shift , indiff_shift , amb_shift , irr_shift
):

    rng = np.random.default_rng(seed)
    curr_labels = env.FrankenData.dist_label.clone().long().numpy().astype(int)
    if np.any(curr_labels < 0):
        raise ValueError("Current FrankenData.dist_label contains -1 (unassigned). Assign before SA.")

    # Do a single step with the current labels to produce current opinion update & reward baseline
    action_curr = labels_to_action(curr_labels, env.num_districts)

    _, reward_curr, _, _, _ = env.step(action_curr,eps_indiff , eps_assim ,eps_backfire , eps_irrel , eps_amb ,
                                                            assim_shift , back_shift , indiff_shift , amb_shift , irr_shift )

    ensemble_labels = [env.FrankenData.dist_label.clone().long().numpy().astype(int)]
    ensemble_rewards = [float(reward_curr)]
    ensemble_opinion = [env.FrankenData.opinion.clone().long().numpy().astype(int).flatten()]

    total_steps = hot_steps + anneal_steps + cold_steps
    step_idx = 0


    # Geo-edge in numpy form for contiguity checks
    geo_edge = env.FrankenData.geographical_edge.clone().numpy()

    # MAIN loop: hot -> anneal -> cold
    for phase, n_steps in (("hot", hot_steps), ("anneal", anneal_steps), ("cold", cold_steps)):
        for _ in range(n_steps):
            T = max(T_final, T_init + (T_final - T_init) * (step_idx / max(1, total_steps - 1)))
            step_idx += 1

            # propose
            curr_labels = env.FrankenData.dist_label.clone().long().numpy().astype(int)
            y_prop = propose_flip(curr_labels,geo_edge, rng)

            # Build action for proposal (one-hot rows)
            action_prop = labels_to_action(y_prop, env.num_districts)

            # Evaluate proposal by simulating one step
            _, reward_prop, _, _, _ = env.step(action_prop,eps_indiff = 0, eps_assim = 3,eps_backfire = 3, eps_irrel = 200, eps_amb = 0,
                                                            assim_shift = 1, back_shift = -1, indiff_shift =0, amb_shift = 0, irr_shift =0)   # uses  env.step / env.reward logic

            # Metropolis acceptance on rewards with temperature T:
            # p = min(1, exp((reward_prop - reward_curr)/T))
            diff = float(reward_prop) - float(reward_curr)
            # guard against overflow
            try:
                p_accept = math.exp(diff / max(1e-8, T))
                p_accept = min(1.0, p_accept)
            except OverflowError:
                p_accept = 1.0 if diff > 0 else 0.0


            if rng.random() < p_accept:
                # accept: commit tmp_env as the new working environment
                reward_curr = float(reward_prop)
                ensemble_labels.append(env.FrankenData.dist_label.clone().long().numpy().astype(int))
                ensemble_rewards.append(reward_curr)
                ensemble_opinion.append(env.FrankenData.opinion.clone().long().numpy().astype(int).flatten())
            else:
                # reject: keep current env

                env.reset()

    return env, ensemble_labels, ensemble_rewards, ensemble_opinion

import torch
import numpy as np

# ---- Setup initial data for inchworm ----
num_voters = 10
num_districts = 4
init_opinions = np.array([0,0,0,1,2,3,4,5,5,5], dtype=np.float32).reshape(num_voters, 1)

# trivial positions (not used in inchworm)
pos = np.zeros((num_voters, 2), dtype=np.float32)

# no base edges (inchworm works only via districting)
so_edge = np.empty((2,0),dtype=np.int64)
edge_attr  = np.empty((0,),dtype=np.float32)
geo_edge_attr = np.empty((0,),dtype=np.float32)

# initial geographical (everyone in district 0 for now)
geographical_edge = np.zeros((num_voters, num_voters), dtype=np.float32)
geographical_edge = [
                      [0,0,0,1,0,0,0,0,0,0],
                      [0,0,0,1,0,0,0,0,0,0],
                      [0,0,0,1,0,0,0,0,0,0],
                      [1,1,1,0,1,0,0,1,1,1],
                      [0,0,0,1,0,1,0,0,1,1],
                      [0,0,0,0,1,0,1,0,0,0],
                      [0,0,0,0,0,1,0,1,0,0],
                      [0,0,0,1,0,0,1,0,1,0],
                      [0,0,0,1,1,0,0,1,0,1],
                      [0,0,0,1,1,0,0,0,1,0]
]

dist_label = np.array([1,1,0,0,1,2,2,2,3,0], dtype=np.float32)

# no reps yet
reps = [-1]*num_districts

# adjacency matrix -> undirected edge list
u, v = np.nonzero(geographical_edge)
mask = u < v   # ensures each undirected edge appears only once
geo_edge = np.vstack((u[mask], v[mask])) # shape (num_edges,2)

# pack into FrankenData
init_data = gerry_environment.FrankenData(
    social_edge=so_edge,
    geographical_edge= geo_edge,
    orig_edge_num=2,
    opinion=init_opinions,
    pos=pos,
    reps=reps,
    dist_label=dist_label,
    edge_attr=edge_attr,
    geo_edge_attr=geo_edge_attr
)

env = gerry_environment.FrankenmanderingEnv(num_voters=num_voters,
                          num_districts=num_districts,
                          FrankenData=init_data,
                                               )

obs, _ = env.reset()
print("t=0:", obs.opinion.squeeze().tolist())

_, ensemble_labels, ensemble_rewards, ensemble_opinion = simulated_annealing(env,
    10,
    20,
    10,
    1,
    0.01,
    42,
    0 , 3 ,3 , 200 , 0 ,
    1 , -1 , 0 , 0 , 0 )

print("Final labels:", ensemble_labels)
print("Reward trajectory:", ensemble_rewards)
print("Opinion sequence:" , ensemble_opinion)