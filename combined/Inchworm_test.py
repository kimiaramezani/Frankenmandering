# -*- coding: utf-8 -*-
"""inchworm_test.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sNkLY8TTPxbATIVIkSMd-9aFrzOh4kaT
"""

import numpy as np
import torch
from torch_geometric.data import Data
import gymnasium as gym
from gymnasium import spaces
import gerry_environment
from graph_initiator import build_inchworm_init_data

"""#Inch Worm Test"""

def normalize_array(data,min_val, max_val):
    normal_array = (data - min_val) / (max_val - min_val)
    return np.round(normal_array,2)

# -------- Inchworm (without social graph) Test using the Frankenmendering Paper Values-----------
# Use this function call to get the inchworm specific graph generator
# You can use init_inch_data, _ = build_inchworm_init_data() if you do not need the graph itself

init_inch_data, G_inch = build_inchworm_init_data()
# infer sizes
num_voters = init_inch_data.opinion.shape[0]
num_districts = 1

env = gerry_environment.FrankenmanderingEnv(num_voters=num_voters,
                          num_districts=num_districts,
                          FrankenData=init_inch_data,
                                               )

# reset will now just deepcopy init_data
obs, _ = env.reset()
print("t=0:", obs.opinion.squeeze().tolist())

def run_inchworm(env, districts):
    history = []
    for t, district in enumerate(districts, 1):
        # Build assignment matrix
        assignment = np.zeros((env.num_voters, env.num_districts), dtype=np.float32)
        for v in range(env.num_voters):
            if v in district:
                assignment[v] = 1.0 # Should this be assignment [v] or assignment [v,0]?
                # assignment [v,0] keeps the assignment matrix (N×1) valid for “one evolving district,”
                # instead of setting all columns for that voter to 1.0.
            # else:
            #     assignment[v, 1] = 1.0

        obs, reward, terminated, truncated, info = env.step(assignment,eps_indiff = 0, eps_assim = 3,eps_backfire = 3, eps_irrel = 200, eps_amb = 0,
                                                            assim_shift = 1, back_shift = -1, indiff_shift =0, amb_shift = 0, irr_shift =0)

        opinions = obs.opinion.squeeze().tolist()
        reps = obs.reps.numpy().tolist()
        history.append((opinions, reps))

        print(f"t={t}, reps={reps}, opinions={opinions}")
    return history

districts = [
    [2,3,9],
    [1,3,8],
    [0,3,7],
    [3,4,9],
    [4,5,8],
    [5,6,7],
    [6,7,8],
    [7,8,9]
]

history = run_inchworm(env, districts)

# --- To tun the inchworm with social edges, use build_inchworm_soc_init_data() instead of build_inchworm_init_data() ---
# --- The social edges will be empty in the first case and populated in the second case.

# init_inch_soc_data, G_inch = build_inchworm_soc_init_data()
# # infer sizes
# num_voters = init_inch_soc_data.opinion.shape[0]
# num_districts = 1

# env = gerry_environment.FrankenmanderingEnv(num_voters=num_voters,
#                           num_districts=num_districts,
#                           FrankenData=init_inch_soc_data,
#                                                )


# import numpy as np
# simple test
# def update_opinion(voter_opinion, rep_opinion):
#     """Apply Inchworm update rule for a single voter."""
#     diff = rep_opinion - voter_opinion
#     if abs(diff) < 3:
#         return voter_opinion + np.sign(diff)
#     else:
#         return voter_opinion - np.sign(diff)

# def elect_representative(district, opinions):
#     """Median voter becomes representative."""
#     members = sorted(district, key=lambda i: opinions[i])
#     median_index = members[len(members) // 2]
#     return median_index

# def step_inchworm(opinions, district):
#     """Run one step of Inchworm given a district."""
#     rep = elect_representative(district, opinions)
#     rep_opinion = opinions[rep]
#     new_opinions = opinions.copy()

#     for v in district:
#         if v == rep:
#             continue  # rep stays unchanged
#         new_opinions[v] = update_opinion(opinions[v], rep_opinion)

#     return new_opinions, rep



# for t, d in enumerate(districts, 1):
#     opinions, rep = step_inchworm(opinions, d)
#     print(f"t={t}, rep={rep}, opinions={opinions}")

# res : t=0: [0 0 0 1 2 3 4 5 5 5]
# t=1, rep=3, opinions=[0 0 1 1 2 3 4 5 5 6]
# t=2, rep=3, opinions=[0 1 1 1 2 3 4 5 6 6]
# t=3, rep=3, opinions=[1 1 1 1 2 3 4 6 6 6]
# t=4, rep=4, opinions=[1 1 1 2 2 3 4 6 6 7]
# t=5, rep=5, opinions=[1 1 1 2 3 3 4 6 7 7]
# t=6, rep=6, opinions=[1 1 1 2 3 4 4 5 7 7]
# t=7, rep=7, opinions=[1 1 1 2 3 4 5 5 6 7]
# t=8, rep=8, opinions=[1 1 1 2 3 4 5 6 6 6]




