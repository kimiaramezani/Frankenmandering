# -*- coding: utf-8 -*-
"""Report_Gen_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WJIvTyKAGAutjNhsBFlqwx-YFkT6hY65
"""

import numpy as np
import matplotlib.pyplot as plt
import os

# ---------------------------
# LINE CHARTS ACROSS RUNS
# ---------------------------

def plot_line(xs, ys, xlabel, ylabel, title, save_path):
    plt.figure(figsize=(6, 3.5))
    plt.plot(xs, ys, marker='o', linestyle='-', color='C0')
    plt.xticks(xs, xs + 1)  # assuming xs are 0-indexed run_ids
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.grid(alpha=0.25)

    # annotate each point
    for x, y in zip(xs, ys):
        offset = 0.01 * (np.max(ys) - np.min(ys) if np.max(ys)!=np.min(ys) else 1.0)
        yloc = y + offset if y >= 0 else y - offset
        plt.text(x, yloc, f"{y:.3f}", ha='center', va='bottom' if y>=0 else 'top', fontsize=8)

    plt.tight_layout()
    plt.savefig(save_path)
    plt.close()

def plot_stacked_bar(xs, counts, category_labels, xlabel, ylabel, title, save_path, figsize=(6, 3.5)):

    counts = np.array(counts)
    if counts.shape[0] != len(xs):
        raise ValueError("counts must have the same number of rows as xs")

    bottom = np.zeros(len(xs))
    plt.figure(figsize=figsize)
    for i, label in enumerate(category_labels):
        plt.bar(xs, counts[:, i], bottom=bottom, label=label)
        bottom += counts[:, i]

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.legend(title="Category", bbox_to_anchor=(1.05, 1), loc="upper left")
    plt.tight_layout()
    plt.savefig(save_path)
    plt.close()

def pairwise_hamming_mean(samples):
    n = len(samples)
    dists = []
    for i in range(n):
        for j in range(i+1, n):
            dists.append(np.mean(samples[i] != samples[j]))
    return np.mean(dists)

def plot_summary_each_run(run_id, save_dir, num_bins, rewards, acc_hist, opinions):
    """
    Generate and save stacked-bar opinion evolution, reward, and acceptance plots.
    """
    # --- Opinion evolution (stacked bar) ---
    if opinions.shape[0] > 1:
        op_array = np.array(opinions)
        bins = np.linspace(np.min(op_array), np.max(op_array), num_bins + 1)
        bin_labels = [f"{bins[i]:.1f}-{bins[i+1]:.1f}" for i in range(num_bins)]

        counts = np.zeros((op_array.shape[0], num_bins))
        for t in range(op_array.shape[0]):
            hist, _ = np.histogram(op_array[t, :], bins=bins)
            if np.sum(hist) > 0:
                counts[t] = hist / np.sum(hist)  # normalize to proportions

        # x = np.arange(op_array.shape[0])
        # bottom = np.zeros(op_array.shape[0])
        xs = np.arange(len(counts))

        save_path = os.path.join(save_dir, f"run_{run_id+1}_opinions_stacked.png")

        plot_stacked_bar(
            xs=xs,
            counts=counts,
            category_labels=bin_labels,
            xlabel="Accepted Step",
            ylabel="Proportion of Opinions",
            title=f"Run {run_id+1} - Opinion Evolution (Stacked Distribution)",
            save_path=save_path
        )

        # plt.figure(figsize=(6, 3.5))
        # for i in range(num_bins):
        #     plt.bar(x, counts[:, i], bottom=bottom, label=bin_labels[i])
        #     bottom += counts[:, i]

        # plt.title(f"Run {run_id+1} - Opinion Evolution (Stacked Distribution)")
        # plt.xlabel("Accepted Step")
        # plt.ylabel("Proportion of Opinions")
        # plt.legend(title="Opinion Range", bbox_to_anchor=(1.05, 1), loc="upper left")
        # plt.tight_layout()
        # plt.savefig(os.path.join(save_dir, f"run_{run_id+1}_opinions_stacked.png"))
        # plt.close()

    # --- Reward trajectory plot ---
        xs = np.arange(len(rewards))

        # Define save path
        save_path = os.path.join(save_dir, f"run_{run_id+1}_reward.png")

        # Call the general-purpose line plotting function
        plot_line(
            xs=xs,
            ys=rewards,
            xlabel="Accepted Step",
            ylabel="Reward",
            title=f"Run {run_id+1} - Reward Trajectory",
            save_path=save_path
        )

    # --- Acceptance history plot ---
    if len(acc_hist) > 0:
      xs = np.arange(len(acc_hist))
      save_path = os.path.join(save_dir, f"run_{run_id+1}_acceptance.png")

      plot_line(
          xs=xs,
          ys=acc_hist,
          xlabel="Checkpoint (x10 steps)",
          ylabel="Acceptance Rate",
          title=f"Run {run_id+1} - Acceptance History",
          save_path=save_path
      )

def plot_summary_global(save_dir,num_runs, df, metric_map,ylabels):

    report_path = os.path.join(save_dir, "global_report.txt")

    with open(report_path, "w") as f:
        f.write("=== GLOBAL MCMC REPORT ===\n\n")
        f.write(f"Total runs: {num_runs}\n")
        f.write(f"Best final reward: {df['final_reward'].max():.3f} (Run {df['final_reward'].idxmax()+1})\n\n")

        f.write("Average Statistics:\n")
        for col in ["final_reward", "avg_accept_rate", "avg_dist_from_ideal",
                    "ratio_shift_macro", "ratio_shift_micro"]:
            f.write(f"  {col}: mean={df[col].mean():.4f}, std={df[col].std():.4f}\n")
        f.write("\nCorrelations:\n")
        f.write(str(df.corr().round(3)))
        f.write("\n")


    df = df.sort_values("run_id").reset_index(drop=True)

    # metric_map = {
    #     "mean_opinion": "final_mean_opinion",
    #     "delta_opinion": "delta_opinion",
    #     "avg_dist_from_ideal": "avg_dist_from_ideal",
    #     "ratio_shift_micro": "ratio_shift_micro",
    # }
    # ylabels = {
    #     "mean_opinion": "Final Mean Opinion",
    #     "delta_opinion": "Opinion Shift ",
    #     "avg_dist_from_ideal": "Avg Distance from Ideal",
    #     "ratio_shift_micro": "Avg per-step Opinion Change",
    # }

    trend_dir = os.path.join(save_dir, "trend_lines")
    os.makedirs(trend_dir, exist_ok=True)

    xs = np.arange(len(df))

    # Individual line charts
    for pretty_name, col in metric_map.items():
        ys = df[col].values
        fname = os.path.join(trend_dir, f"line_{pretty_name}.png")
        plot_line(xs, ys, xlabel="Run ID", ylabel=ylabels[pretty_name],
                        title=f"{ylabels[pretty_name]} â€” all runs", save_path=fname)

    # Combined 2x2 figure
    fig, axes = plt.subplots(2, 2, figsize=(11, 7))
    axes = axes.flatten()

    for ax, pretty_name in zip(axes, metric_map.keys()):
        ys = df[metric_map[pretty_name]].values
        ax.plot(xs, ys, marker='o', linestyle='-', color='C0')
        ax.set_xticks(xs)
        ax.set_xticklabels((df["run_id"]).astype(str))
        ax.set_title(ylabels[pretty_name])
        ax.set_xlabel("Run ID")
        # annotate
        for x, y in zip(xs, ys):
            offset = 0.01 * (np.max(ys) - np.min(ys) if np.max(ys)!=np.min(ys) else 1.0)
            yloc = y + offset if y >= 0 else y - offset
            ax.text(x, yloc, f"{y:.3f}", ha='center', va='bottom' if y>=0 else 'top', fontsize=8)
        ax.grid(alpha=0.25)

    plt.tight_layout()
    combined_fname = os.path.join(trend_dir, "combined_lines.png")
    plt.savefig(combined_fname)
    plt.close()